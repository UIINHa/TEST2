#include <windows.h>
#include <tlhelp32.h>
#include <iostream>
#include <cmath>
#include <thread>

// ===== 설정 =====
#define ENTITY_LIST_OFFSET 0x10F4F8
#define LOCAL_PLAYER_OFFSET  0x10F4F4
#define ENTITY_SIZE 0x1EC
#define MAX_PLAYERS 32
#define OFFSET_X 0x04
#define OFFSET_Y 0x08
#define OFFSET_Z 0x0C
#define OFFSET_HP 0x30
#define OFFSET_ALIVE 0x20C
#define OFFSET_VIEW_X 0x34
#define OFFSET_VIEW_Y 0x38

// ===== 모듈 주소 가져오기 =====
uintptr_t GetModuleBaseAddress(DWORD pid, const wchar_t* modName) {
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    MODULEENTRY32 modEntry;
    modEntry.dwSize = sizeof(modEntry);

    if (Module32First(hSnap, &modEntry)) {
        do {
            if (!_wcsicmp(modEntry.szModule, modName)) {
                CloseHandle(hSnap);
                return (uintptr_t)modEntry.modBaseAddr;
            }
        } while (Module32Next(hSnap, &modEntry));
    }

    CloseHandle(hSnap);
    return 0;
}

void AimAt(HANDLE hProc, DWORD localPlayer, float ex, float ey, float ez) {
    float myX, myY, myZ;
    ReadProcessMemory(hProc, (LPCVOID)(localPlayer + OFFSET_X), &myX, sizeof(float), nullptr);
    ReadProcessMemory(hProc, (LPCVOID)(localPlayer + OFFSET_Y), &myY, sizeof(float), nullptr);
    ReadProcessMemory(hProc, (LPCVOID)(localPlayer + OFFSET_Z), &myZ, sizeof(float), nullptr);

    float dx = ex - myX;
    float dy = ey - myY;
    float dz = ez - myZ;

    float hypotenuse = sqrtf(dx * dx + dy * dy);

    float yaw = atan2f(dy, dx) * (180.0f / 3.14159f);
    float pitch = -atan2f(dz, hypotenuse) * (180.0f / 3.14159f);

    WriteProcessMemory(hProc, (LPVOID)(localPlayer + OFFSET_VIEW_X), &yaw, sizeof(float), nullptr);
    WriteProcessMemory(hProc, (LPVOID)(localPlayer + OFFSET_VIEW_Y), &pitch, sizeof(float), nullptr);
}

float GetDistance(float x1, float y1, float z1, float x2, float y2, float z2) {
    return sqrtf((x2 - x1)*(x2 - x1) + (y2 - y1)*(y2 - y1) + (z2 - z1)*(z2 - z1));
}

int main() {
    HWND hwnd = FindWindowA(NULL, "AssaultCube");
    if (!hwnd) return 1;

    DWORD pid;
    GetWindowThreadProcessId(hwnd, &pid);
    HANDLE hProc = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (!hProc) return 1;

    uintptr_t base = GetModuleBaseAddress(pid, L"ac_client.exe");
    uintptr_t localPlayerPtrAddr = base + LOCAL_PLAYER_OFFSET;
    uintptr_t entityListBase = base + ENTITY_LIST_OFFSET;

    DWORD localPlayer;
    ReadProcessMemory(hProc, (LPCVOID)localPlayerPtrAddr, &localPlayer, sizeof(DWORD), nullptr);

    float myX, myY, myZ;

    while (true) {
        ReadProcessMemory(hProc, (LPCVOID)(localPlayer + OFFSET_X), &myX, sizeof(float), nullptr);
        ReadProcessMemory(hProc, (LPCVOID)(localPlayer + OFFSET_Y), &myY, sizeof(float), nullptr);
        ReadProcessMemory(hProc, (LPCVOID)(localPlayer + OFFSET_Z), &myZ, sizeof(float), nullptr);

        float closestDist = FLT_MAX;
        DWORD closestEnemy = 0;
        float ex = 0, ey = 0, ez = 0;

        for (int i = 1; i < MAX_PLAYERS; ++i) {
            DWORD entityAddr;
            ReadProcessMemory(hProc, (LPCVOID)(entityListBase + i * 4), &entityAddr, sizeof(DWORD), nullptr);
            if (entityAddr == 0 || entityAddr == localPlayer) continue;

            int hp = 0;
            int alive = 0;
            ReadProcessMemory(hProc, (LPCVOID)(entityAddr + OFFSET_HP), &hp, sizeof(int), nullptr);
            ReadProcessMemory(hProc, (LPCVOID)(entityAddr + OFFSET_ALIVE), &alive, sizeof(int), nullptr);

            if (hp <= 0 || alive != 1) continue;

            float tx, ty, tz;
            ReadProcessMemory(hProc, (LPCVOID)(entityAddr + OFFSET_X), &tx, sizeof(float), nullptr);
            ReadProcessMemory(hProc, (LPCVOID)(entityAddr + OFFSET_Y), &ty, sizeof(float), nullptr);
            ReadProcessMemory(hProc, (LPCVOID)(entityAddr + OFFSET_Z), &tz, sizeof(float), nullptr);

            float dist = GetDistance(myX, myY, myZ, tx, ty, tz);
            if (dist < closestDist) {
                closestDist = dist;
                closestEnemy = entityAddr;
                ex = tx; ey = ty; ez = tz;
            }
        }

        if (closestEnemy != 0 && closestDist < 100.0f) {
            AimAt(hProc, localPlayer, ex, ey, ez);
        }

        Sleep(10);
    }

    CloseHandle(hProc);
    return 0;
}
